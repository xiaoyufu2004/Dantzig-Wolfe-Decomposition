---
title: "DW分解学习笔记"
author: "Daisy"
format: html
---

# 学习资料
张树柱老师的DW分解课程：

- 知乎课件：<https://zhuanlan.zhihu.com/p/524111484>

- B站网课：<https://www.bilibili.com/video/BV1k3411V7FG?spm_id_from=333.788.recommend_more_video.20&trackid=web_related_0.router-related-2206146-wxmlq.1761879901781.498&vd_source=1c1c9d895c2baf1bb8ad3b5e5d47051f>

# 背景
- **DW 分解**是针对**块角（block–angular）结构**的大规模线性/混合整数规划的分解方法。  
- **思想：**把原问题中彼此独立的“子块”保留在各自可行域内求解，只通过少量**耦合约束**（资源/平衡）连接，然后用**列生成**逐步丰富主问题的列。  
- 与**列生成（CG）**的关系：DW 把“多面体可行域”写成**极点 + 极方向**的凸/锥组合；列就是这些极点/极方向在主问题中的权重。

# 原理
## 原问题
DW分解适用于块角结构的问题。设共有 $S$ 个子块，决策 $x=[x_1;\dots;x_S]$ 。

$$
\begin{aligned}
\min \quad   & \sum_{s=1}^S c_s^\top x_s \\
\text{s.t.}\quad
             & \sum_{s=1}^S A_s x_s \;\le\; b \quad \text{(耦合/系统约束)}\\
             & B_s x_s \;\le\; d_s,\quad x_s \ge 0 \qquad (s=1,\dots,S).
\end{aligned}
\tag{P}
\label{P}
$$

这里 \(A_s\) 只出现在少量系统级约束中，而 \(B_s\) 仅作用于各自子块。

![原问题结构](originalprob.png)

## 极点 + 极方向表示

基于Minkowski定理，记子块可行域 $X_s=\{x_s\mid B_s x_s\le d_s,\ x_s\ge 0\}$。存在极点集 $V_s=\{v_s^k\}$ 与极方向集 $D_s=\{d_s^r\}$，使

$$
x_s=\sum_{k\in\mathcal K_s}\lambda_{sk}v_s^k+\sum_{r\in\mathcal R_s}w_{sr}d_s^r,\qquad
\sum_k \lambda_{sk}=1,\ \lambda_{sk}\ge 0,\ w_{sr}\ge 0 .
$$

## 限制主问题（RMP）

把上式代回原问题，得到列形式主问题；实际只保留少量列形成 RMP：

$$
\begin{aligned}
\min\quad
& \sum_{s}\sum_{k} (c_s^\top v_s^k)\lambda_{sk}
  + \sum_{s}\sum_{r} (c_s^\top d_s^r)w_{sr} \\
\text{s.t.}\quad
& \sum_{s}\sum_{k} (A_s v_s^k)\lambda_{sk}
  + \sum_{s}\sum_{r} (A_s d_s^r)w_{sr} \le b,\\
& \sum_{k}\lambda_{sk}=1 \ (s=1,\dots,S),\\
& \lambda_{sk}\ge0,\ w_{sr}\ge0 .
\end{aligned}
$$

## 对偶主问题（Dual RMP）
把耦合约束写成 $\sum_s A_s x_s \le b$ ，其对偶为 
$(\pi \ge 0)$ ；每个子块的凸性等式 $\sum_k \lambda_{sk}=1$ 的对偶为自由变量 $\mu_s$ 。

$$
\max \ b^\top \pi + \sum_{s}\mu_s
$$

对极点列（对所有 $s$ 与 $t\in\mathcal T_s$）：

$$
(A_s v_s^t)^\top \pi + \mu_s \le c_s^\top v_s^t
$$

对极方向列（若存在，对所有 $s$ 与 $r\in\mathcal R_s$）：

$$
(A_s d_s^r)^\top \pi \le c_s^\top d_s^r
$$

对偶变量取值域：

$$
\pi \ge 0
$$

$$
\mu_s \in \mathbb{R}
$$

> 对最小化问题，若存在一列使 $\bar c < 0$，意味着把这列少量加入会降低目标值，当前 RMP 还不最优；因此需要把它加入。反之，若所有列的约化成本都不负，则 RMP 已经是原问题的最优。最大化问题只需把不等号方向反过来：出现 $\bar c > 0$ 的列就应加入，直到 $\bar c(\cdot) \le 0$ 。

> 读对偶时，RMP 建议用单纯形（如 Gurobi `Method=1`），以确保可以取到约束的 `.Pi`。 

## 定价子问题（Pricing）

给定当前对偶 $(\pi,\mu)$，对每个子块 $s$ 解：

### 极点定价（点子问题）
$$
\min_{x_s}\ (c_s-A_s^\top\pi)^\top x_s-\mu_s
\quad\text{s.t.}\quad B_s x_s\le d_s,\ x_s\ge0 .
$$

### 极方向定价（方向子问题）
$$
\min_{d}\ (c_s-A_s^\top\pi)^\top d
\quad\text{s.t.}\quad B_s d\le 0,\ d\ge0 .
$$

若点子问题无界，应求方向子问题并把方向列加入 RMP（方向列不受凸性等式约束）。

# 算法步骤

1. **初始化**：每个子块给出至少一个可行极点，初始化列集合。设容差 $\varepsilon>0$。
2. **解 RMP**：得到目标值 $z_{\text{RMP}}$ 与对偶 $(\pi,\mu)$；更新 $UB=\min(UB,\ z_{\text{RMP}})$。
3. **定价**：对每个子块解点/方向子问题；若出现 $\bar c<-\varepsilon$ （最小化问题）的列则加入 RMP。
4. **收敛判据**：若无改进列，则迭代停止，否则返回步骤 2。

# 例子
## 问题描述
**Maximize**
$$
\max\; 14x_1 + 8x_2 + 11x_3 + 7x_4
$$
$$
2.1x_1 + 2.1x_2 + 0.75x_3 + 0.75x_4 \le 60
$$
$$
0.5x_1 + 0.5x_2 + 0.5x_3 + 0.5x_4 \le 25
$$
$$
x_1 + x_2 \ge 22
$$
$$
x_1 \le 20
$$
$$
x_3 + x_4 \ge 12
$$
$$
x_3 \le 15
$$
$$
x_4 \le 25
$$
$$
x_1,x_2,x_3,x_4 \ge 0
$$

将变量分为 $\{x_1,x_2\}$ 与 $\{x_3,x_4\}$ 两部分，对应两个子问题。令
$$
c_1=\begin{bmatrix}14\\[2pt]8\end{bmatrix},\quad
c_2=\begin{bmatrix}11\\[2pt]7\end{bmatrix},
$$
$$
A_1=\begin{bmatrix}2.1&2.1\\[2pt]0.5&0.5\end{bmatrix},\quad
A_2=\begin{bmatrix}0.75&0.75\\[2pt]0.5&0.5\end{bmatrix},\quad
b=\begin{bmatrix}60\\[2pt]25\end{bmatrix}.
$$

- 子问题1约束：
  $$x_1+x_2\ge 22,\;\; x_1\le 20.$$

- 子问题2约束：
  $$x_3+x_4\ge 12,\;\; x_3\le 15,\;\; x_4\le 25.$$
  
## 手动求解
![](example1.png)
![](example2.png)

## gurobipy代码实现

```{python}

import gurobipy as gp
from gurobipy import GRB
import numpy as np
import time
# ==========================
# 数据定义
# ==========================
c1 = np.array([14, 8])     # 对应 x1, x2
c2 = np.array([11, 7])     # 对应 x3, x4

A1 = np.array([[2.1, 2.1],
               [0.5, 0.5]])
A2 = np.array([[0.75, 0.75],
               [0.5, 0.5]])

b = np.array([60, 25])

# 子问题局部约束
B1 = np.array([[1, 1],   # x1 + x2 <= 22
               [1, 0]])  # x1 <= 20
b1 = np.array([22, 20])

B2 = np.array([[1, 1],   # x3 + x4 <= 12
               [1, 0],   # x3 <= 15
               [0, 1]])  # x4 <= 25
b2 = np.array([12, 15, 25])

# ==========================
# 初始极点（至少给每块一个可行点）
# ==========================
X1_points = [np.array([0., 22.])]   # v1^1
X2_points = [np.array([0., 12.])]   # v2^1

# 初始极方向集合（开始为空）
X1_rays = []
X2_rays = []

# ==========================
# Master Problem（含极点和极方向）
# ==========================
def solve_master_problem(X1_pts, X2_pts, X1_rays, X2_rays, A1, A2, b, c1, c2):
    m = gp.Model("RMP")
    # λ for points; w for rays
    lam1 = m.addVars(len(X1_pts), lb=0, name="lam1")
    lam2 = m.addVars(len(X2_pts), lb=0, name="lam2")
    w1   = m.addVars(len(X1_rays), lb=0, name="w1")
    w2   = m.addVars(len(X2_rays), lb=0, name="w2")

    # 目标
    m.setObjective(
        gp.quicksum(c1 @ X1_pts[i]  * lam1[i] for i in range(len(X1_pts))) +
        gp.quicksum(c2 @ X2_pts[j]  * lam2[j] for j in range(len(X2_pts))) +
        gp.quicksum(c1 @ X1_rays[r] * w1[r]   for r in range(len(X1_rays))) +
        gp.quicksum(c2 @ X2_rays[s] * w2[s]   for s in range(len(X2_rays))),
        GRB.MAXIMIZE
    )

    # 耦合资源约束 A1*x1 + A2*x2 <= b
    for k in range(len(b)):
        m.addConstr(
            gp.quicksum(A1[k, :] @ X1_pts[i]  * lam1[i] for i in range(len(X1_pts))) +
            gp.quicksum(A2[k, :] @ X2_pts[j]  * lam2[j] for j in range(len(X2_pts))) +
            gp.quicksum(A1[k, :] @ X1_rays[r] * w1[r]   for r in range(len(X1_rays))) +
            gp.quicksum(A2[k, :] @ X2_rays[s] * w2[s]   for s in range(len(X2_rays)))
            <= b[k], name=f"res_{k}"
        )

    # 凸性约束：仅对 λ 生效
    m.addConstr(gp.quicksum(lam1[i] for i in range(len(X1_pts))) == 1, "conv1")
    m.addConstr(gp.quicksum(lam2[j] for j in range(len(X2_pts))) == 1, "conv2")

    m.setParam('OutputFlag', 0)
    m.setParam('Method', 1)  # 单纯形以便读取 .Pi
    m.optimize()

    if m.status != GRB.OPTIMAL:
        raise RuntimeError("RMP not optimal.")

    # 取对偶：耦合约束 π、凸性约束 μ
    pi  = [m.getConstrByName(f"res_{k}").Pi for k in range(len(b))]
    mu1 = m.getConstrByName("conv1").Pi
    mu2 = m.getConstrByName("conv2").Pi
    return (pi, mu1, mu2), m.objVal, m

# ==========================
# 极点定价（带 μ）
# ==========================
def solve_point_pricing(c, A, B, b, pi, mu):
    rc = c - A.T @ np.array(pi)
    m = gp.Model("PointPricing")
    x = m.addMVar(len(c), lb=0, name="x")
    # max (c - A^T pi)^T x - mu
    m.setObjective(rc @ x - mu, GRB.MAXIMIZE)
    m.addConstr(B @ x <= b)
    m.setParam('OutputFlag', 0)
    m.optimize()
    if m.status == GRB.OPTIMAL:
        return m.objVal, x.X
    return None, None

# ==========================
# 极方向定价（不含 μ；加归一化以取代表性方向）
# ==========================
def solve_ray_pricing(c, A, B, pi):
    rc = c - A.T @ np.array(pi)
    m = gp.Model("RayPricing")
    d = m.addMVar(len(c), lb=0, name="d")
    m.setObjective(rc @ d, GRB.MAXIMIZE)
    m.addConstr(B @ d <= 0)     # 齐次约束 => 方向
    m.addConstr(d.sum() <= 1)   # 归一化以避免无界，方便拿到一个 ray
    m.setParam('OutputFlag', 0)
    m.optimize()
    if m.status == GRB.OPTIMAL:
        return m.objVal, d.X
    return None, None

# ==========================
# 迭代
# ==========================
tol = 1e-8
t0=time.perf_counter()
for it in range(50):
    (pi, mu1, mu2), obj, rmp = solve_master_problem(
        X1_points, X2_points, X1_rays, X2_rays, A1, A2, b, c1, c2
    )
    print(f"Iter {it+1:02d} | RMP obj={obj:.6f} | pi={pi} | mu=({mu1:.6f},{mu2:.6f})")

    # 定价：极点
    rc1_p, x1_new = solve_point_pricing(c1, A1, B1, b1, pi, mu1)
    rc2_p, x2_new = solve_point_pricing(c2, A2, B2, b2, pi, mu2)

    # 定价：极方向
    rc1_r, d1_new = solve_ray_pricing(c1, A1, B1, pi)
    rc2_r, d2_new = solve_ray_pricing(c2, A2, B2, pi)

    print(f"  RC point: X1={rc1_p:.6f}, X2={rc2_p:.6f} | RC ray: X1={rc1_r:.6f}, X2={rc2_r:.6f}")

    added = False
    # 只要 reduced cost > tol 就加入对应列
    if rc1_p is not None and rc1_p > tol:
        X1_points.append(x1_new); added = True
        print(f"  + add X1 point {x1_new}")
    if rc2_p is not None and rc2_p > tol:
        X2_points.append(x2_new); added = True
        print(f"  + add X2 point {x2_new}")
    if rc1_r is not None and rc1_r > tol:
        X1_rays.append(d1_new); added = True
        print(f"  + add X1 ray   {d1_new}")
    if rc2_r is not None and rc2_r > tol:
        X2_rays.append(d2_new); added = True
        print(f"  + add X2 ray   {d2_new}")

    if not added:
        print("No improving columns/rays. Optimal for DW RMP.\n")
        break
t1=time.perf_counter()
print(f"Total time: {t1-t0:.3f} seconds")
# （可选）从最终RMP还原 x1, x2：
# lam、w 的值可通过 rmp.getVarByName 读取并线性组合。
```
